<#@ template language="C#" #>
<#@ assembly name="$(TargetPath)" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Snoop.DataAccess.Sessions" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Security.Principal" #>
using System;
using System.Linq;
using System.Collections.Generic;
using Snoop.DataAccess.Interfaces;
using Snoop.DataAccess.Sessions;
using Snoop.DataAccess.Internal.Interfaces;
// ReSharper disable HeapView.BoxingAllocation

namespace Snoop.DataAccess.Impl {

<#
    var interfaces = typeof(ISession).Assembly.GetTypes().Where(x => x.IsInterface).Where(x => x.Namespace.StartsWith("Snoop.DataAccess.Interfaces")).ToList();
#>
    partial class Marshaller {
        static List<(Type tInterface, Func<object, IExecutor> factoryServer, Func<ISession, string, IDataAccess> factoryClient)> registeredTypes = new List<(Type tInterface, Func<object, IExecutor> factoryServer, Func<ISession, string, IDataAccess> factoryClient)>
        {<#
    foreach (var type in interfaces)
        
    {
#> 
            (typeof(<#=type#>), x=>new <#=type.Name#>Server((<#=type#>)x), (s, x)=>new <#=type.Name#>Client(s, x) ),
<#        
    }
#>
        };
        public static IExecutor CreateServerExecutor(Type type, object instance) {
            var info = registeredTypes.FirstOrDefault(x => x.tInterface == type);
            return info.factoryServer(instance);
        }
        public static IDataAccess CreateClientExecutor(ISession session, Type type, string id) {
            var info = registeredTypes.FirstOrDefault(x => x.tInterface == type);
            return info.factoryClient(session, id);
        }
    }
<#
    foreach (var type in interfaces)
    {
#>     
    public sealed class <#=type.Name#>Server : IExecutor {
        readonly <#=type.Name#> source;
        readonly string id;
        public <#=type.Name#>Server(<#=type.Name#> source){
            this.source = source;
            this.id = Guid.NewGuid().ToString();
        }
        public object Execute(string methodName, ICallInfo parameters) {
<#
    foreach (var property in type.GetProperties())
    {
        if (property.GetMethod != null)
        {
#>
            if(methodName=="<#=property.GetMethod.Name #>") {
                return source.<#=property.Name #>;
            }
<#
        }
        if (property.SetMethod != null)
        {
#>
            if(methodName=="<#=property.SetMethod.Name #>") {
                source.<#=property.Name #> = ((CallInfo<<#=type.Name#>Client.PackedArgs_<#=property.SetMethod.Name #>>)parameters).Args.value;
                return null;
            }
<#
        }
    }
    foreach (var method in type.GetMethods())
    {
        if (method.IsSpecialName)
            continue;
#>
            if(methodName=="<#=method.Name #>") {
<#
        if (method.ReturnType != typeof(void))
            Write("                return ");
        else
            Write("                ");
#>source.<#=method.Name#>(<#WriteServerMethodCallParameters(method);#>);<#
        if (method.ReturnType == typeof(void))
            Write("\r\n                return null;");
#>                 
            }
<#        
    }
#>
            return null;
        }
    }
    public sealed class <#=type.Name #>Client : <#=type #>, IDataAccessClient {
        readonly string id;
        public ISession Session {get; set;}
        public <#=type.Name #>Client(ISession session, string id) {
            this.id = id;
            Session = session;
        }
        public string Id { get { return id; } }
<#
    foreach (var method in type.GetMethods())
    {
#>
        public class PackedArgs_<#=method.Name#> {
<#
    foreach (var pi in method.GetParameters())
    {
        #>
        public <#=pi.ParameterType#> <#=pi.Name#> { get; set; }
<#
    }
#>
        } 
<#
    }
//PROPERTY
    foreach (var property in type.GetProperties())
    {
#>
        public <#=property.PropertyType #> <#=property.Name #> {
<#
//PROPERTY GETTER
    getter:
    if (property.GetMethod == null)
        goto setter;
#>
            get { return Marshaller.Call<<#=type #>, <#=property.PropertyType #>, object>(this, true, "<#=property.GetMethod.Name #>", null); }
<#
//PROPERTY SETTER
    setter:
    if (property.SetMethod == null)
        goto propertyEnd;
#>
            set { Marshaller.Call<<#=type #>, <#=property.PropertyType #>, PackedArgs_<#=property.SetMethod.Name#>>(this, false, "<#=property.SetMethod.Name #>", value, new PackedArgs_<#=property.SetMethod.Name#>() { value = value }); }
<#
    propertyEnd:
#>
        }
<#
    }
//METHOD
    foreach (var method in type.GetMethods())
    {
        if (method.IsSpecialName)
            continue;
        var mrt = method.ReturnType == typeof(void) ? (object)"void" : method.ReturnType;
#>
        public <#=mrt#> <#=method.Name#>(<#WriteClientMethodParameters(method.GetParameters());#>) { <#WriteMethodCall(type, method);#> }
<#
    }

#>    }
<#
    }
#>
}<#

    void WriteClientMethodParameters(ParameterInfo[] parameterInfos)
    {
        if(parameterInfos.Length == 0)
            return;
        for (int i = 0; i < parameterInfos.Length; i++)
        {
            var pi = parameterInfos[i];
            Write($"{pi.ParameterType} {pi.Name}");
            if(i == parameterInfos.Length-1)
                break;
            Write(", ");
        }
    }
#><#+
    string WriteClientMethodCallArgs(MethodInfo method)
    {
        var parameterInfos = method.GetParameters();
        StringBuilder builder = new StringBuilder();
        builder.Append($"new PackedArgs_{method.Name}(){{");
        for (int i = 0; i < parameterInfos.Length; i++)
        {
            if (i != 0)
                builder.Append(", ");
            var pi = parameterInfos[i];
            builder.Append($"{pi.Name} = {pi.Name}");
        }
        builder.Append("}");
        return builder.ToString();
    }
    private void WriteMethodCall(Type source, MethodInfo method)
    {
        var mType = typeof(object);
        if (method.ReturnType != typeof(void))
        {
            Write("return ");
            mType = method.ReturnType;
        }
        var wait = method.ReturnType != typeof(void) ? "true" : "false";

        Write($@"Marshaller.Call<{source}, {mType}, PackedArgs_{method.Name}>(this, {wait}, ""{method.Name}"", {WriteClientMethodCallArgs(method)});");
    }

    void WriteServerMethodCallParameters(MethodInfo method)
    {
        var parameters = method.GetParameters();
        for (int i = 0; i < parameters.Length; i++)
        {
            var pi = parameters[i];
            Write($@"((CallInfo<{method.DeclaringType.Name}Client.PackedArgs_{method.Name}>)parameters).Args.{pi.Name}");
            if(i == parameters.Length-1)
                break;
            Write(", ");
        }
    }
#>