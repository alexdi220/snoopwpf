<#@ template language="C#" #>
<#@ assembly name="$(TargetPath)" #>
<#@ assembly name="System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Snoop.DataAccess.Sessions" #>
<#@ import namespace="System.Collections.Generic" #>
/*
 * THIS CODE IS AUTO-GENERATED
 */
using System;
using System.Linq;
using System.Collections.Generic;
using Snoop.DataAccess.Interfaces;
using Snoop.DataAccess.Sessions;
using Snoop.DataAccess.Internal.Interfaces;
// ReSharper disable HeapView.BoxingAllocation

namespace Snoop.DataAccess.Impl {

<#
    var interfaces = typeof(ISession).Assembly.GetTypes().Where(x => x.IsInterface).Where(x => x.Namespace.StartsWith("Snoop.DataAccess.Interfaces")).ToList();
#>
    partial class Marshaller {
        static Marshaller() {
            registeredTypes = new List<(Type tInterface, Func<object, IExecutor> factoryServer, Func<ISession, string, IDataAccess> factoryClient)> {
<#
        foreach (var type in interfaces) {
#>                 (typeof(<#=type #>), x=>new <#=type.Name #>Server((<#=type #>)x), (s, x)=>new <#=type.Name #>Client(s, x) ),
<#
        }
#>
            };        
        }
    }
<#
    foreach (var type in interfaces) {
#>     
    internal sealed class <#=type.Name #>Server : IExecutor {
        readonly <#=type.Name #> source;
        public string Id { get; }
        readonly Dictionary<string, int> eventCounter; 
        public <#=type.Name #>Server(<#=type.Name #> source){
            this.source = source;
            this.Id = source.Id;
            this.eventCounter = new Dictionary<string, int>();
<#
    foreach (var eventInfo in FlaternInterfaces(type).SelectMany(x=>x.GetEvents())) {
#>
            this.eventCounter["<#=eventInfo.Name #>"] = 0;
<#
    }
#>
        }
<#
    foreach (var eventInfo in FlaternInterfaces(type).SelectMany(x=>x.GetEvents())) {
        var ehInvoke = eventInfo.EventHandlerType.GetMethod("Invoke");
#>
        <#=TypeToString(ehInvoke.ReturnType)#> On<#=eventInfo.Name #>(<#=GetClientMethodParameters(ehInvoke.GetParameters()) #>){
            <#=ehInvoke.ReturnType==typeof(void) ? "" : "return "#>Marshaller.Call<<#=type#>, <#=ehInvoke.ReturnType == typeof(void) ? "object" : TypeToString(ehInvoke.ReturnType)#>, <#=type.Name#>Client.PackedArgs_<#=eventInfo.Name#>>(this, <#=ehInvoke.ReturnType!=typeof(void) ? "true" : "false"#>, "Raise<#=eventInfo.Name #>", <#=WriteClientMethodCallArgs(ehInvoke,eventInfo.Name, $"{type.Name}Client.")#>);
        }
<#
    }
#>

        public object Execute(string methodName, ICallInfo parameters) {
<#
    //events
    foreach (var eventInfo in FlaternInterfaces(type).SelectMany(x=>x.GetEvents())) {
        if (eventInfo.AddMethod != null) {
#>
            if(methodName=="<#=eventInfo.AddMethod.Name #>") {
                var count = eventCounter["<#=eventInfo.Name#>"];
                if(count==0) {
                    source.<#=eventInfo.Name #> += On<#=eventInfo.Name #>;
                }
                eventCounter["<#=eventInfo.Name#>"] = count + 1;
            }
<#
        }
        if (eventInfo.RemoveMethod != null) {
#>
            if(methodName=="<#=eventInfo.RemoveMethod.Name #>") {
                var count = eventCounter["<#=eventInfo.Name#>"];
                if(count==1) {
                    source.<#=eventInfo.Name #> -= On<#=eventInfo.Name #>;
                }
                eventCounter["<#=eventInfo.Name#>"] = count - 1;
            }
<#
        }
    }
    //properties
    foreach (var property in FlaternInterfaces(type).SelectMany(x=>x.GetProperties())) {
        if (property.GetMethod != null) {
#>
            if(methodName=="<#=property.GetMethod.Name #>") {
                return source.<#=property.Name #>;
            }
<#
        }
        if (property.SetMethod != null) {
#>
            if(methodName=="<#=property.SetMethod.Name #>") {
                source.<#=property.Name #> = ((CallInfo<<#=type.Name #>Client.PackedArgs_<#=property.SetMethod.Name #>>)parameters).Args.value;
                return null;
            }
<#
        }
    }
    //methods
    foreach (var method in FlaternInterfaces(type).SelectMany(x=>x.GetMethods())) {
        if (method.IsSpecialName)
            continue;
#>
            if(methodName=="<#=method.Name #>") {
<#
        if (method.ReturnType != typeof(void))
            Write("                return ");
        else
            Write("                ");
#>source.<#=method.Name #>(<#
        WriteServerMethodCallParameters(method, type); #>);<#
        if (method.ReturnType == typeof(void))
            Write("\r\n                return null;");
#>                 
            }
<#
    }
#>
            return null;
        }
    }
    internal sealed class <#=type.Name #>Client : <#=type #>, IDataAccessClient {
        readonly string id;
        public ISession Session {get; set;}
        public <#=type.Name #>Client(ISession session, string id) {
            this.id = id;
            Session = session;
        }
        public string Id { get { return id; } }
    internal class PackedArgs_UnusedArgs {
    }
<#
    foreach (var method in FlaternInterfaces(type).SelectMany(x=>x.GetMethods())) {
        if (method.IsSpecialName && method.Name.StartsWith("add_") || method.Name.StartsWith("remove_"))
            continue;
        DefinePackedArgs(method, method.Name);
    }
    foreach (var eventInfo in FlaternInterfaces(type).SelectMany(x=>x.GetEvents())) {
        DefinePackedArgs(eventInfo.EventHandlerType.GetMethod("Invoke"), eventInfo.Name);
    }
    //PROPERTY
    foreach (var property in FlaternInterfaces(type).SelectMany(x=>x.GetProperties())) {
#>
        public <#=TypeToString(property.PropertyType) #> <#=property.Name #> {
<#
    //PROPERTY GETTER
    if (property.GetMethod == null)
        goto setter;
#>
            get { return Marshaller.Call<<#=type #>, <#=TypeToString(property.PropertyType) #>, PackedArgs_<#=property.GetMethod.Name #>>(this, true, "<#=property.GetMethod.Name #>", new PackedArgs_<#=property.GetMethod.Name #>()); }
<#
    //PROPERTY SETTER
    setter:
    if (property.SetMethod == null)
        goto propertyEnd;
#>
            set { Marshaller.Call<<#=type #>, <#=TypeToString(property.PropertyType) #>, PackedArgs_<#=property.SetMethod.Name #>>(this, false, "<#=property.SetMethod.Name #>", new PackedArgs_<#=property.SetMethod.Name #>() { value = value }); }
<#
    propertyEnd:
#>
        }
<#
    }
    //METHOD
    foreach (var method in FlaternInterfaces(type).SelectMany(x=>x.GetMethods())) {
        if (method.IsSpecialName)
            continue;
#>
        public <#=TypeToString(method.ReturnType) #> <#=method.Name #>(<#=GetClientMethodParameters(method.GetParameters())#>) { <#
        WriteMethodCall(type, method); #> }
<#
    }
    //EVENT
    foreach (var eventInfo in type.GetInterfaces().Concat(new[] { type }).Where(x => !x.FullName.StartsWith("Snoop.DataAccess.Internal")).SelectMany(x => x.GetEvents())) {
        var invoke = eventInfo.EventHandlerType.GetMethod("Invoke");
        var wait = invoke.ReturnType != typeof(void) ? "true" : "false";
#>
    <#=TypeToString(eventInfo.EventHandlerType)#> _<#=eventInfo.Name#>;
        public event <#=TypeToString(eventInfo.EventHandlerType)#> <#=eventInfo.Name#> {
            add {  
                 _<#=eventInfo.Name#> += value;
                 Marshaller.Call<<#=type #>, object, PackedArgs_UnusedArgs>(this, <#=wait#>, "add_<#=eventInfo.Name #>", new PackedArgs_UnusedArgs()); 
            }
            remove {
                 _<#=eventInfo.Name#> -= value;
                 Marshaller.Call<<#=type #>, object, PackedArgs_UnusedArgs>(this, <#=wait#>, "remove_<#=eventInfo.Name #>", new PackedArgs_UnusedArgs());
            }
        }
        public <#=TypeToString(invoke.ReturnType)#> Raise<#=eventInfo.Name#>(<#=GetClientMethodParameters(invoke.GetParameters())#>) {
            <#=invoke.ReturnType != typeof(void) ? "return" : ""#> _<#=eventInfo.Name#>(<#=string.Join(", ", invoke.GetParameters().Select(x=>x.Name))#>);
        }
<#
    }

#>    }
<#
    }
#>
}<#
    string GetClientMethodParameters(ParameterInfo[] parameterInfos) { return string.Join(", ", parameterInfos.Select(x => $"{TypeToString(x.ParameterType)} {x.Name}")); }

    void DefinePackedArgs(MethodInfo method, string name) {
#>
        internal class PackedArgs_<#=name #> {
<#
    foreach (var pi in method.GetParameters()) {
#>
        public <#=TypeToString(pi.ParameterType) #> <#=pi.Name #> { get; set; }
<#
    }
#>
        }
<#
    }

#><#+
    IEnumerable<Type> FlaternInterfaces(Type source) {
        return source
               .GetInterfaces()
               .Concat(new[] { source })
               .Where(x => !x.FullName.StartsWith("Snoop.DataAccess.Internal"))
            ;
    }
    string TypeToString(Type type) {
        if (type == typeof(void))
            return "void";
        if (type.GenericTypeArguments.Length != 0) {
            var fullname = type.GetGenericTypeDefinition().FullName; 
            return $"{fullname.Substring(0, fullname.IndexOf('`'))}<{string.Join(", ", type.GenericTypeArguments.Select(TypeToString))}>";
        }
        return type.ToString();
    }
    string WriteClientMethodCallArgs(MethodInfo method, string name, string prefix = "") {
        var parameterInfos = method.GetParameters();
        var builder = new StringBuilder();
        builder.Append($"new {prefix}PackedArgs_{name}(){{");
        for (var i = 0; i < parameterInfos.Length; i++) {
            if (i != 0)
                builder.Append(", ");
            var pi = parameterInfos[i];
            builder.Append($"{pi.Name} = {pi.Name}");
        }
        builder.Append("}");
        return builder.ToString();
    }

    void WriteMethodCall(Type source, MethodInfo method) {
        var mType = typeof(object);
        if (method.ReturnType != typeof(void)) {
            Write("return ");
            mType = method.ReturnType;
        }
        var wait = method.ReturnType != typeof(void) ? "true" : "false";

        Write($@"Marshaller.Call<{source}, {TypeToString(mType)}, PackedArgs_{method.Name}>(this, {wait}, ""{method.Name}"", {WriteClientMethodCallArgs(method, method.Name)});");
    }

    void WriteServerMethodCallParameters(MethodInfo method, Type declType) {
        var parameters = method.GetParameters();
        for (var i = 0; i < parameters.Length; i++) {
            var pi = parameters[i];
            Write($@"((CallInfo<{declType.Name}Client.PackedArgs_{method.Name}>)parameters).Args.{pi.Name}");
            if (i == parameters.Length - 1)
                break;
            Write(", ");
        }
    }#>